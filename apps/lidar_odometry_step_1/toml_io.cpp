#include "toml_io.h"
#include <iostream>
#include <sstream>

bool TomlIO::SaveParametersToTomlFile(const std::string &filepath, LidarOdometryParams &params)
{
    toml::table tbl;
    for (const auto &[category, attributes] : CATEGORIES)
    {
        toml::table cat_tbl;
        for (const auto &attribute : attributes)
        {
            if (attribute == "in_out_params_indoor" || attribute == "in_out_params_outdoor")
                continue;

            if (attribute == "clear_color")
            {
                const ImVec4& c = params.clear_color;
                cat_tbl.insert(attribute, toml::array{ c.x, c.y, c.z, c.w });
                continue;
            }
            
            // Check if it's a motion_model_correction parameter
            auto motion_it = MOTION_MODEL_CORRECTION_POINTERS.find(attribute);
            if (motion_it != MOTION_MODEL_CORRECTION_POINTERS.end())
            {
                cat_tbl.insert(attribute, params.motion_model_correction.*(motion_it->second));
                continue;
            }
            
            auto it = POINTERS.find(attribute);
            if (it == POINTERS.end())
                continue;
            std::visit([&](auto ptr)
                       { cat_tbl.insert(attribute, params.*ptr); }, it->second);
        }
        tbl.insert(category, std::move(cat_tbl));
    }
    // separate grid params
    auto insert_grid_params = [&](const std::string &name, const NDT::GridParameters &grid)
    {
        toml::table nested_tbl;
        nested_tbl.insert("bounding_box_min_X", grid.bounding_box_min_X);
        nested_tbl.insert("bounding_box_min_Y", grid.bounding_box_min_Y);
        nested_tbl.insert("bounding_box_min_Z", grid.bounding_box_min_Z);
        nested_tbl.insert("bounding_box_max_X", grid.bounding_box_max_X);
        nested_tbl.insert("bounding_box_max_Y", grid.bounding_box_max_Y);
        nested_tbl.insert("bounding_box_max_Z", grid.bounding_box_max_Z);
        nested_tbl.insert("bounding_box_extension", grid.bounding_box_extension);
        nested_tbl.insert("number_of_buckets_X", grid.number_of_buckets_X);
        nested_tbl.insert("number_of_buckets_Y", grid.number_of_buckets_Y);
        nested_tbl.insert("number_of_buckets_Z", grid.number_of_buckets_Z);
        nested_tbl.insert("number_of_buckets", static_cast<int64_t>(grid.number_of_buckets));
        nested_tbl.insert("resolution_X", grid.resolution_X);
        nested_tbl.insert("resolution_Y", grid.resolution_Y);
        nested_tbl.insert("resolution_Z", grid.resolution_Z);
        tbl.insert(name, std::move(nested_tbl));
    };
    insert_grid_params("in_out_params_indoor", params.in_out_params_indoor);
    insert_grid_params("in_out_params_outdoor", params.in_out_params_outdoor);
    
    std::ofstream out(filepath);
    
    // Add header comment with version information
    out << "# HDMapping Configuration File" << std::endl;
    out << "# Generated by HDMapping v" << params.software_version << std::endl;
    out << "# Config version: " << params.config_version << std::endl;
    out << "# Created on: " << params.build_date << std::endl;
    out << "# " << std::endl;
    out << "# This file contains parameters organized in categories." << std::endl;
    out << "# Version information is stored in [version_info] section for compatibility checking." << std::endl;
    out << std::endl;
    
    // Write version_info section first for quick identification
    out << "[version_info]" << std::endl;
    out << "software_version = \"" << params.software_version << "\"" << std::endl;
    out << "config_version = \"" << params.config_version << "\"" << std::endl;
    out << "build_date = \"" << params.build_date << "\"" << std::endl;
    out << std::endl;
    
    // Remove version_info from tbl to avoid duplication since we write it manually
    tbl.erase("version_info");
    
    out << tbl;
    return true;
}

template <typename T>
void TomlIO::set_if_exists(NDT::GridParameters &grid, const toml::table *tbl, const std::string &key, T NDT::GridParameters::*member)
{
    if (!tbl)
        return;
    if (auto it = tbl->find(key); it != tbl->end())
    {
        if (auto val = it->second.value<T>(); val.has_value())
        {
            grid.*member = *val;
        }
    }
}

void TomlIO::read_grid_params(NDT::GridParameters &grid, const toml::table *grid_tbl)
{
    set_if_exists(grid, grid_tbl, "bounding_box_min_X", &NDT::GridParameters::bounding_box_min_X);
    set_if_exists(grid, grid_tbl, "bounding_box_min_Y", &NDT::GridParameters::bounding_box_min_Y);
    set_if_exists(grid, grid_tbl, "bounding_box_min_Z", &NDT::GridParameters::bounding_box_min_Z);
    set_if_exists(grid, grid_tbl, "bounding_box_max_X", &NDT::GridParameters::bounding_box_max_X);
    set_if_exists(grid, grid_tbl, "bounding_box_max_Y", &NDT::GridParameters::bounding_box_max_Y);
    set_if_exists(grid, grid_tbl, "bounding_box_max_Z", &NDT::GridParameters::bounding_box_max_Z);
    set_if_exists(grid, grid_tbl, "bounding_box_extension", &NDT::GridParameters::bounding_box_extension);
    set_if_exists(grid, grid_tbl, "number_of_buckets_X", &NDT::GridParameters::number_of_buckets_X);
    set_if_exists(grid, grid_tbl, "number_of_buckets_Y", &NDT::GridParameters::number_of_buckets_Y);
    set_if_exists(grid, grid_tbl, "number_of_buckets_Z", &NDT::GridParameters::number_of_buckets_Z);
    if (grid_tbl)
    {
        if (auto it = grid_tbl->find("number_of_buckets"); it != grid_tbl->end())
        {
            if (auto val = it->second.value<int>(); val.has_value())
            {
                grid.number_of_buckets = static_cast<size_t>(*val);
            }
        }
    }
    set_if_exists(grid, grid_tbl, "resolution_X", &NDT::GridParameters::resolution_X);
    set_if_exists(grid, grid_tbl, "resolution_Y", &NDT::GridParameters::resolution_Y);
    set_if_exists(grid, grid_tbl, "resolution_Z", &NDT::GridParameters::resolution_Z);
}

bool TomlIO::LoadParametersFromTomlFile(const std::string &filepath, LidarOdometryParams &params)
{
    toml::table tbl;
    try
    {
        tbl = toml::parse_file(filepath);
    }
    catch (const toml::parse_error &err)
    {
        std::cerr << "Parsing failed:\n"
                  << err << "\n";
        return false;
    }
    for (const auto &[category, attributes] : CATEGORIES)
    {
        auto cat_it = tbl.find(category);
        if (cat_it == tbl.end())
            continue;
        const auto &cat_tbl = cat_it->second.as_table();
        if (!cat_tbl)
            continue;
        for (const auto &attribute : attributes)
        {
            // grid params will be processed separately
            if (attribute == "in_out_params_indoor" || attribute == "in_out_params_outdoor")
                continue;
            
            // Check if it's a motion_model_correction parameter
            auto motion_it = MOTION_MODEL_CORRECTION_POINTERS.find(attribute);
            if (motion_it != MOTION_MODEL_CORRECTION_POINTERS.end())
            {
                auto attr_it = cat_tbl->find(attribute);
                if (attr_it != cat_tbl->end())
                {
                    params.motion_model_correction.*(motion_it->second) = attr_it->second.value_or(0.0);
                }
                continue;
            }
            
            auto it = POINTERS.find(attribute);
            if (it == POINTERS.end())
                continue;
            auto attr_it = cat_tbl->find(attribute);
            if (attr_it == cat_tbl->end())
                continue;
            std::visit([&](auto ptr)
                       {
                        using MemberType = std::remove_reference_t<decltype(params.*ptr)>;
                        if constexpr (std::is_same_v<MemberType, bool>) {
                            params.*ptr = attr_it->second.value_or(false);
                        }
                        else if constexpr (std::is_same_v<MemberType, int>) {
                            params.*ptr = static_cast<int>(attr_it->second.value_or<int64_t>(0));
                        }
                        else if constexpr (std::is_same_v<MemberType, double>) {
                            params.*ptr = attr_it->second.value_or(0.0);
                        }
                        else if constexpr (std::is_same_v<MemberType, std::string>) {
                            params.*ptr = attr_it->second.value_or(std::string{});
                        } }, it->second);
        }

        if (cat_tbl && cat_tbl->contains("clear_color"))
        {
            auto arr = cat_tbl->at("clear_color").as_array();
            if (arr && arr->size() == 4)
            {
                params.clear_color.x = static_cast<float>(arr->at(0).as_floating_point()->get());
                params.clear_color.y = static_cast<float>(arr->at(1).as_floating_point()->get());
                params.clear_color.z = static_cast<float>(arr->at(2).as_floating_point()->get());
                params.clear_color.w = static_cast<float>(arr->at(3).as_floating_point()->get());
            }
        }
    }
    read_grid_params(params.in_out_params_indoor, tbl["in_out_params_indoor"].as_table());
    read_grid_params(params.in_out_params_outdoor, tbl["in_out_params_outdoor"].as_table());
    
    // Check and handle version information
    auto version_info = CheckConfigVersion(filepath);
    if (!version_info.found) {
        std::cout << "WARNING: No version information found in config file: " << filepath << std::endl;
        std::cout << "   This config was created with an older version of HDMapping." << std::endl;
        HandleMissingVersion(params);
    } else {
        std::string current_version = get_software_version();
        if (!IsVersionCompatible(version_info.software_version, current_version)) {
            std::cout << "WARNING: Version mismatch detected:" << std::endl;
            std::cout << "   Config version: " << version_info.software_version << std::endl;
            std::cout << "   Current version: " << current_version << std::endl;
            std::cout << "   Config created on: " << version_info.build_date << std::endl;
            std::cout << "   Consider updating the configuration file." << std::endl;
        } else {
            std::cout << "SUCCESS: Version compatible: " << current_version << std::endl;
        }
    }
    
    return true;
}

// Version validation and handling implementations
TomlIO::VersionInfo TomlIO::CheckConfigVersion(const std::string &filepath) {
    VersionInfo info;
    
    try {
        auto config = toml::parse_file(filepath);
        
        if (config.contains("version_info")) {
            auto version_section = config["version_info"].as_table();
            if (version_section) {
                auto sw_ver = version_section->get("software_version");
                auto cfg_ver = version_section->get("config_version");
                auto build_dt = version_section->get("build_date");
                
                info.software_version = sw_ver ? sw_ver->as_string()->get() : "";
                info.config_version = cfg_ver ? cfg_ver->as_string()->get() : "";
                info.build_date = build_dt ? build_dt->as_string()->get() : "";
                info.found = true;
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Error checking version in config: " << e.what() << std::endl;
    }
    
    return info;
}

bool TomlIO::IsVersionCompatible(const std::string &file_version, const std::string &current_version) {
    if (file_version.empty() || current_version.empty()) {
        return false;
    }
    
    // Parse version numbers (simple implementation)
    auto parse_version = [](const std::string& version) {
        std::vector<int> parts;
        std::stringstream ss(version);
        std::string item;
        while (std::getline(ss, item, '.')) {
            try {
                parts.push_back(std::stoi(item));
            } catch (...) {
                parts.push_back(0);
            }
        }
        return parts;
    };
    
    auto file_parts = parse_version(file_version);
    auto current_parts = parse_version(current_version);
    
    // Ensure both have at least 3 parts (major.minor.patch)
    while (file_parts.size() < 3) file_parts.push_back(0);
    while (current_parts.size() < 3) current_parts.push_back(0);
    
    // Compatible if major and minor versions match
    return (file_parts[0] == current_parts[0]) && (file_parts[1] == current_parts[1]);
}

void TomlIO::HandleMissingVersion(LidarOdometryParams &params) {
    // Set current version information for missing version configs
    params.software_version = get_software_version();
    params.config_version = "1.0";
    params.build_date = __DATE__;
    
    std::cout << "   -> Updated config with current version: " << params.software_version << std::endl;
    std::cout << "   -> Consider saving the config to persist version information." << std::endl;
}